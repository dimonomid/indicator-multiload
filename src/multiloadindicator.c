/* multiloadindicator.c generated by valac 0.14.2, the Vala compiler
 * generated from multiloadindicator.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <libayatana-appindicator/app-indicator.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>


#define TYPE_MULTI_LOAD_INDICATOR (multi_load_indicator_get_type ())
#define MULTI_LOAD_INDICATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MULTI_LOAD_INDICATOR, MultiLoadIndicator))
#define MULTI_LOAD_INDICATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MULTI_LOAD_INDICATOR, MultiLoadIndicatorClass))
#define IS_MULTI_LOAD_INDICATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MULTI_LOAD_INDICATOR))
#define IS_MULTI_LOAD_INDICATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MULTI_LOAD_INDICATOR))
#define MULTI_LOAD_INDICATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MULTI_LOAD_INDICATOR, MultiLoadIndicatorClass))

typedef struct _MultiLoadIndicator MultiLoadIndicator;
typedef struct _MultiLoadIndicatorClass MultiLoadIndicatorClass;
typedef struct _MultiLoadIndicatorPrivate MultiLoadIndicatorPrivate;

#define TYPE_PROVIDERS (providers_get_type ())
#define PROVIDERS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PROVIDERS, Providers))
#define PROVIDERS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PROVIDERS, ProvidersClass))
#define IS_PROVIDERS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PROVIDERS))
#define IS_PROVIDERS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PROVIDERS))
#define PROVIDERS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PROVIDERS, ProvidersClass))

typedef struct _Providers Providers;
typedef struct _ProvidersClass ProvidersClass;

#define TYPE_MENU_MODEL (menu_model_get_type ())
#define MENU_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MENU_MODEL, MenuModel))
#define MENU_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MENU_MODEL, MenuModelClass))
#define IS_MENU_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MENU_MODEL))
#define IS_MENU_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MENU_MODEL))
#define MENU_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MENU_MODEL, MenuModelClass))

typedef struct _MenuModel MenuModel;
typedef struct _MenuModelClass MenuModelClass;

#define TYPE_GRAPH_MODELS (graph_models_get_type ())
#define GRAPH_MODELS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GRAPH_MODELS, GraphModels))
#define GRAPH_MODELS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GRAPH_MODELS, GraphModelsClass))
#define IS_GRAPH_MODELS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GRAPH_MODELS))
#define IS_GRAPH_MODELS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GRAPH_MODELS))
#define GRAPH_MODELS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GRAPH_MODELS, GraphModelsClass))

typedef struct _GraphModels GraphModels;
typedef struct _GraphModelsClass GraphModelsClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_source_unref0(var) ((var == NULL) ? NULL : (var = (g_source_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_EXPRESSION_CACHE (expression_cache_get_type ())
#define EXPRESSION_CACHE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_EXPRESSION_CACHE, ExpressionCache))
#define EXPRESSION_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_EXPRESSION_CACHE, ExpressionCacheClass))
#define IS_EXPRESSION_CACHE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_EXPRESSION_CACHE))
#define IS_EXPRESSION_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_EXPRESSION_CACHE))
#define EXPRESSION_CACHE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_EXPRESSION_CACHE, ExpressionCacheClass))

typedef struct _ExpressionCache ExpressionCache;
typedef struct _ExpressionCacheClass ExpressionCacheClass;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))

#define TYPE_GRAPH_MODEL (graph_model_get_type ())
#define GRAPH_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GRAPH_MODEL, GraphModel))
#define GRAPH_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GRAPH_MODEL, GraphModelClass))
#define IS_GRAPH_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GRAPH_MODEL))
#define IS_GRAPH_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GRAPH_MODEL))
#define GRAPH_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GRAPH_MODEL, GraphModelClass))

typedef struct _GraphModel GraphModel;
typedef struct _GraphModelClass GraphModelClass;

#define TYPE_TRACE_MODEL (trace_model_get_type ())
#define TRACE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRACE_MODEL, TraceModel))
#define TRACE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRACE_MODEL, TraceModelClass))
#define IS_TRACE_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRACE_MODEL))
#define IS_TRACE_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRACE_MODEL))
#define TRACE_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRACE_MODEL, TraceModelClass))

typedef struct _TraceModel TraceModel;
typedef struct _TraceModelClass TraceModelClass;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

struct _MultiLoadIndicator {
	GObject parent_instance;
	MultiLoadIndicatorPrivate * priv;
};

struct _MultiLoadIndicatorClass {
	GObjectClass parent_class;
};

struct _MultiLoadIndicatorPrivate {
	guint currenticonindex;
	guint lasticonwidth;
	GSource* timeout;
	AppIndicator* indicator;
	GtkMenuItem** menuitems;
	gint menuitems_length1;
	gint _menuitems_size_;
	gboolean menuset;
	gchar* _icondirectory;
	Providers* _providers;
	MenuModel* _menumodel;
	MenuModel* _labelmodel;
	MenuModel* _descriptionmodel;
	gint _indicator_index;
	guint _height;
	guint _width;
	guint _speed;
	GtkMenu* _menu;
	GraphModels* _graphmodels;
};

struct _Block1Data {
	int _ref_count_;
	MultiLoadIndicator * self;
	gboolean found;
};


static gpointer multi_load_indicator_parent_class = NULL;

GType multi_load_indicator_get_type (void) G_GNUC_CONST;
GType providers_get_type (void) G_GNUC_CONST;
GType menu_model_get_type (void) G_GNUC_CONST;
GType graph_models_get_type (void) G_GNUC_CONST;
#define MULTI_LOAD_INDICATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MULTI_LOAD_INDICATOR, MultiLoadIndicatorPrivate))
enum  {
	MULTI_LOAD_INDICATOR_DUMMY_PROPERTY,
	MULTI_LOAD_INDICATOR_ICONDIRECTORY,
	MULTI_LOAD_INDICATOR_PROVIDERS,
	MULTI_LOAD_INDICATOR_MENUMODEL,
	MULTI_LOAD_INDICATOR_LABELMODEL,
	MULTI_LOAD_INDICATOR_DESCRIPTIONMODEL,
	MULTI_LOAD_INDICATOR_INDICATOR_INDEX,
	MULTI_LOAD_INDICATOR_HEIGHT,
	MULTI_LOAD_INDICATOR_WIDTH,
	MULTI_LOAD_INDICATOR_SPEED,
	MULTI_LOAD_INDICATOR_MENU,
	MULTI_LOAD_INDICATOR_GRAPHMODELS
};
static gchar* multi_load_indicator_iconpath (MultiLoadIndicator* self, guint index);
const gchar* multi_load_indicator_get_icondirectory (MultiLoadIndicator* self);
MultiLoadIndicator* multi_load_indicator_new (const gchar* icondirectory, Providers* providers);
MultiLoadIndicator* multi_load_indicator_construct (GType object_type, const gchar* icondirectory, Providers* providers);
MenuModel* menu_model_new (Providers* providers);
MenuModel* menu_model_construct (GType object_type, Providers* providers);
void multi_load_indicator_destroy (MultiLoadIndicator* self);
void multi_load_indicator_updateall (MultiLoadIndicator* self);
static void multi_load_indicator_updateproviders (MultiLoadIndicator* self);
static void multi_load_indicator_updatemodels (MultiLoadIndicator* self);
static void multi_load_indicator_updateviews (MultiLoadIndicator* self);
Providers* multi_load_indicator_get_providers (MultiLoadIndicator* self);
void providers_update (Providers* self);
MenuModel* multi_load_indicator_get_menumodel (MultiLoadIndicator* self);
void menu_model_update (MenuModel* self);
MenuModel* multi_load_indicator_get_labelmodel (MultiLoadIndicator* self);
MenuModel* multi_load_indicator_get_descriptionmodel (MultiLoadIndicator* self);
GraphModels* multi_load_indicator_get_graphmodels (MultiLoadIndicator* self);
void graph_models_update (GraphModels* self, guint trace_length);
guint multi_load_indicator_get_width (MultiLoadIndicator* self);
static void multi_load_indicator_updatemenuview (MultiLoadIndicator* self);
static void multi_load_indicator_updatelabelview (MultiLoadIndicator* self);
static void multi_load_indicator_updategraphsview (MultiLoadIndicator* self);
GtkMenu* multi_load_indicator_get_menu (MultiLoadIndicator* self);
gchar** menu_model_get_expressions (MenuModel* self, int* result_length1);
static void _vala_array_add12 (GtkMenuItem*** array, int* length, int* size, GtkMenuItem* value);
GType expression_cache_get_type (void) G_GNUC_CONST;
ExpressionCache* menu_model_expression (MenuModel* self, guint index);
gchar* expression_cache_label (ExpressionCache* self);
static GtkMenuItem** _vala_array_dup16 (GtkMenuItem** self, int length);
gint multi_load_indicator_get_indicator_index (MultiLoadIndicator* self);
gchar* expression_cache_guide (ExpressionCache* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static void multi_load_indicator_iconwrite (MultiLoadIndicator* self);
static void ____lambda3_ (Block1Data* _data1_, GtkWidget* w);
guint multi_load_indicator_get_height (MultiLoadIndicator* self);
static void _____lambda3__gtk_callback (GtkWidget* widget, gpointer self);
static gchar* multi_load_indicator_iconname (MultiLoadIndicator* self, guint index);
static void multi_load_indicator_iconwritedummy (MultiLoadIndicator* self);
GType graph_model_get_type (void) G_GNUC_CONST;
GraphModel** graph_models_get_graphmodels (GraphModels* self, int* result_length1);
gboolean graph_model_get_enabled (GraphModel* self);
void graph_model_set_source_color (GraphModel* self, cairo_t* ctx);
GType trace_model_get_type (void) G_GNUC_CONST;
TraceModel** graph_model_get_tracemodels (GraphModel* self, int* result_length1);
static TraceModel** _vala_array_dup17 (TraceModel** self, int length);
gdouble graph_model_get_scale (GraphModel* self);
gboolean trace_model_get_enabled (TraceModel* self);
gdouble* trace_model_get_values (TraceModel* self, int* result_length1);
void trace_model_get_color (TraceModel* self, GdkColor* result);
static void multi_load_indicator_set_icondirectory (MultiLoadIndicator* self, const gchar* value);
static void multi_load_indicator_set_providers (MultiLoadIndicator* self, Providers* value);
static void multi_load_indicator_set_menumodel (MultiLoadIndicator* self, MenuModel* value);
static void multi_load_indicator_set_labelmodel (MultiLoadIndicator* self, MenuModel* value);
static void multi_load_indicator_set_descriptionmodel (MultiLoadIndicator* self, MenuModel* value);
void multi_load_indicator_set_indicator_index (MultiLoadIndicator* self, gint value);
void multi_load_indicator_set_height (MultiLoadIndicator* self, guint value);
void multi_load_indicator_set_width (MultiLoadIndicator* self, guint value);
guint multi_load_indicator_get_speed (MultiLoadIndicator* self);
void multi_load_indicator_set_speed (MultiLoadIndicator* self, guint value);
void multi_load_indicator_set_menu (MultiLoadIndicator* self, GtkMenu* value);
void multi_load_indicator_set_graphmodels (MultiLoadIndicator* self, GraphModels* value);
static GObject * multi_load_indicator_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _multi_load_indicator___lambda4_ (MultiLoadIndicator* self, gint delta, guint direction);
static void __multi_load_indicator___lambda4__app_indicator_scroll_event (AppIndicator* _sender, gint delta, guint direction, gpointer self);
static void _multi_load_indicator___lambda5_ (MultiLoadIndicator* self);
static void __multi_load_indicator___lambda5__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void _multi_load_indicator___lambda6_ (MultiLoadIndicator* self);
static gboolean __lambda7_ (MultiLoadIndicator* self);
static gboolean ___lambda7__gsource_func (gpointer self);
static void __multi_load_indicator___lambda6__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void multi_load_indicator_finalize (GObject* obj);
static void _vala_multi_load_indicator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_multi_load_indicator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


MultiLoadIndicator* multi_load_indicator_construct (GType object_type, const gchar* icondirectory, Providers* providers) {
	MultiLoadIndicator * self = NULL;
	const gchar* _tmp0_;
	Providers* _tmp1_;
	Providers* _tmp2_;
	MenuModel* _tmp3_;
	MenuModel* _tmp4_;
	Providers* _tmp5_;
	MenuModel* _tmp6_;
	MenuModel* _tmp7_;
	Providers* _tmp8_;
	MenuModel* _tmp9_;
	MenuModel* _tmp10_;
	g_return_val_if_fail (icondirectory != NULL, NULL);
	g_return_val_if_fail (IS_PROVIDERS (providers), NULL);
	_tmp0_ = icondirectory;
	_tmp1_ = providers;
	_tmp2_ = providers;
	_tmp3_ = menu_model_new (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = providers;
	_tmp6_ = menu_model_new (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = providers;
	_tmp9_ = menu_model_new (_tmp8_);
	_tmp10_ = _tmp9_;
	self = (MultiLoadIndicator*) g_object_new (object_type, "icondirectory", _tmp0_, "providers", _tmp1_, "menumodel", _tmp4_, "labelmodel", _tmp7_, "descriptionmodel", _tmp10_, NULL);
	_g_object_unref0 (_tmp10_);
	_g_object_unref0 (_tmp7_);
	_g_object_unref0 (_tmp4_);
	return self;
}


MultiLoadIndicator* multi_load_indicator_new (const gchar* icondirectory, Providers* providers) {
	return multi_load_indicator_construct (TYPE_MULTI_LOAD_INDICATOR, icondirectory, providers);
}


void multi_load_indicator_destroy (MultiLoadIndicator* self) {
	GSource* _tmp0_;
	GSource* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = self->priv->timeout;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = self->priv->timeout;
	g_source_destroy (_tmp1_);
	_g_source_unref0 (self->priv->timeout);
	self->priv->timeout = NULL;
}


void multi_load_indicator_updateall (MultiLoadIndicator* self) {
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	multi_load_indicator_updateproviders (self);
	multi_load_indicator_updatemodels (self);
	multi_load_indicator_updateviews (self);
}


static void multi_load_indicator_updateproviders (MultiLoadIndicator* self) {
	Providers* _tmp0_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = self->priv->_providers;
	providers_update (_tmp0_);
}


static void multi_load_indicator_updatemodels (MultiLoadIndicator* self) {
	MenuModel* _tmp0_;
	MenuModel* _tmp1_;
	MenuModel* _tmp2_;
	GraphModels* _tmp3_;
	guint _tmp4_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = self->priv->_menumodel;
	menu_model_update (_tmp0_);
	_tmp1_ = self->priv->_labelmodel;
	menu_model_update (_tmp1_);
	_tmp2_ = self->priv->_descriptionmodel;
	menu_model_update (_tmp2_);
	_tmp3_ = self->priv->_graphmodels;
	_tmp4_ = self->priv->_width;
	graph_models_update (_tmp3_, _tmp4_);
}


static void multi_load_indicator_updateviews (MultiLoadIndicator* self) {
	GtkMenu* _tmp0_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	multi_load_indicator_updatemenuview (self);
	multi_load_indicator_updatelabelview (self);
	multi_load_indicator_updategraphsview (self);
	_tmp0_ = self->priv->_menu;
	if (_tmp0_ != NULL) {
		gboolean _tmp1_ = FALSE;
		AppIndicator* _tmp2_;
		const gchar* _tmp3_ = NULL;
		gint _tmp4_;
		gint _tmp5_;
		gboolean _tmp19_;
		AppIndicator* _tmp21_;
		_tmp2_ = self->priv->indicator;
		_tmp3_ = app_indicator_get_icon (_tmp2_);
		_tmp4_ = strlen (_tmp3_);
		_tmp5_ = _tmp4_;
		if (_tmp5_ == 0) {
			gboolean _tmp6_ = FALSE;
			AppIndicator* _tmp7_;
			gchar* _tmp8_ = NULL;
			gchar* _tmp9_;
			gchar* _tmp10_;
			gboolean _tmp11_;
			gboolean _tmp18_;
			_tmp7_ = self->priv->indicator;
			g_object_get (_tmp7_, "label", &_tmp8_, NULL);
			_tmp9_ = _tmp8_;
			_tmp10_ = _tmp9_;
			_tmp11_ = _tmp10_ == NULL;
			_g_free0 (_tmp10_);
			if (_tmp11_) {
				_tmp6_ = TRUE;
			} else {
				AppIndicator* _tmp12_;
				gchar* _tmp13_ = NULL;
				gchar* _tmp14_;
				gchar* _tmp15_;
				gint _tmp16_;
				gint _tmp17_;
				_tmp12_ = self->priv->indicator;
				g_object_get (_tmp12_, "label", &_tmp13_, NULL);
				_tmp14_ = _tmp13_;
				_tmp15_ = _tmp14_;
				_tmp16_ = strlen (_tmp15_);
				_tmp17_ = _tmp16_;
				_tmp6_ = _tmp17_ == 0;
				_g_free0 (_tmp15_);
			}
			_tmp18_ = _tmp6_;
			_tmp1_ = _tmp18_;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp19_ = _tmp1_;
		if (_tmp19_) {
			AppIndicator* _tmp20_;
			_tmp20_ = self->priv->indicator;
			app_indicator_set_label (_tmp20_, "indicator-multiload", "indicator-multiload");
		}
		_tmp21_ = self->priv->indicator;
		app_indicator_set_status (_tmp21_, APP_INDICATOR_STATUS_ACTIVE);
	} else {
		AppIndicator* _tmp22_;
		_tmp22_ = self->priv->indicator;
		app_indicator_set_status (_tmp22_, APP_INDICATOR_STATUS_PASSIVE);
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _vala_array_add12 (GtkMenuItem*** array, int* length, int* size, GtkMenuItem* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (GtkMenuItem*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static GtkMenuItem** _vala_array_dup16 (GtkMenuItem** self, int length) {
	GtkMenuItem** result;
	int i;
	result = g_new0 (GtkMenuItem*, length + 1);
	for (i = 0; i < length; i++) {
		GtkMenuItem* _tmp0_;
		_tmp0_ = _g_object_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void multi_load_indicator_updatemenuview (MultiLoadIndicator* self) {
	GtkMenu* _tmp0_;
	guint menu_position;
	MenuModel* _tmp1_;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gint length;
	gint _tmp32_;
	GtkMenuItem** _tmp33_;
	gint _tmp33__length1;
	gboolean _tmp47_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = self->priv->_menu;
	if (_tmp0_ == NULL) {
		return;
	}
	menu_position = (guint) 2;
	_tmp1_ = self->priv->_menumodel;
	_tmp2_ = menu_model_get_expressions (_tmp1_, &_tmp2__length1);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _tmp2__length1;
	length = _tmp3__length1;
	{
		guint j;
		j = (guint) 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				guint _tmp7_;
				gint _tmp8_;
				GtkMenuItem* item = NULL;
				guint _tmp9_;
				GtkMenuItem** _tmp10_;
				gint _tmp10__length1;
				GtkMenuItem* _tmp24_;
				MenuModel* _tmp25_;
				guint _tmp26_;
				ExpressionCache* _tmp27_ = NULL;
				ExpressionCache* _tmp28_;
				gchar* _tmp29_ = NULL;
				gchar* _tmp30_;
				guint _tmp31_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					guint _tmp6_;
					_tmp6_ = j;
					j = _tmp6_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp7_ = j;
				_tmp8_ = length;
				if (!(_tmp7_ < ((guint) _tmp8_))) {
					break;
				}
				_tmp9_ = j;
				_tmp10_ = self->priv->menuitems;
				_tmp10__length1 = self->priv->menuitems_length1;
				if (_tmp9_ < ((guint) _tmp10__length1)) {
					GtkMenuItem** _tmp11_;
					gint _tmp11__length1;
					guint _tmp12_;
					GtkMenuItem* _tmp13_;
					GtkMenuItem* _tmp14_;
					_tmp11_ = self->priv->menuitems;
					_tmp11__length1 = self->priv->menuitems_length1;
					_tmp12_ = j;
					_tmp13_ = _tmp11_[_tmp12_];
					_tmp14_ = _g_object_ref0 (_tmp13_);
					_g_object_unref0 (item);
					item = _tmp14_;
				} else {
					GtkMenuItem* _tmp15_;
					GtkMenuItem* _tmp16_;
					GtkMenuItem* _tmp17_;
					GtkMenu* _tmp18_;
					GtkMenuItem* _tmp19_;
					guint _tmp20_;
					GtkMenuItem** _tmp21_;
					gint _tmp21__length1;
					GtkMenuItem* _tmp22_;
					GtkMenuItem* _tmp23_;
					_tmp15_ = (GtkMenuItem*) gtk_menu_item_new ();
					_tmp16_ = g_object_ref_sink (_tmp15_);
					_g_object_unref0 (item);
					item = _tmp16_;
					_tmp17_ = item;
					gtk_widget_set_visible (GTK_WIDGET (_tmp17_), TRUE);
					_tmp18_ = self->priv->_menu;
					_tmp19_ = item;
					_tmp20_ = menu_position;
					gtk_menu_shell_insert (GTK_MENU_SHELL (_tmp18_), GTK_WIDGET (_tmp19_), (gint) _tmp20_);
					_tmp21_ = self->priv->menuitems;
					_tmp21__length1 = self->priv->menuitems_length1;
					_tmp22_ = item;
					_tmp23_ = _g_object_ref0 (_tmp22_);
					_vala_array_add12 (&self->priv->menuitems, &self->priv->menuitems_length1, &self->priv->_menuitems_size_, _tmp23_);
				}
				_tmp24_ = item;
				_tmp25_ = self->priv->_menumodel;
				_tmp26_ = j;
				_tmp27_ = menu_model_expression (_tmp25_, _tmp26_);
				_tmp28_ = _tmp27_;
				_tmp29_ = expression_cache_label (_tmp28_);
				_tmp30_ = _tmp29_;
				gtk_menu_item_set_label (_tmp24_, _tmp30_);
				_g_free0 (_tmp30_);
				_g_object_unref0 (_tmp28_);
				_tmp31_ = menu_position;
				menu_position = _tmp31_ + 1;
				_g_object_unref0 (item);
			}
		}
	}
	_tmp32_ = length;
	_tmp33_ = self->priv->menuitems;
	_tmp33__length1 = self->priv->menuitems_length1;
	if (_tmp32_ != _tmp33__length1) {
		GtkMenuItem** _tmp44_;
		gint _tmp44__length1;
		gint _tmp45_;
		GtkMenuItem** _tmp46_;
		gint _tmp46__length1;
		{
			gint _tmp34_;
			guint j;
			GtkMenuItem** _tmp35_;
			gint _tmp35__length1;
			guint jsize;
			_tmp34_ = length;
			j = (guint) _tmp34_;
			_tmp35_ = self->priv->menuitems;
			_tmp35__length1 = self->priv->menuitems_length1;
			jsize = (guint) _tmp35__length1;
			{
				gboolean _tmp36_;
				_tmp36_ = TRUE;
				while (TRUE) {
					gboolean _tmp37_;
					guint _tmp39_;
					guint _tmp40_;
					GtkMenuItem** _tmp41_;
					gint _tmp41__length1;
					guint _tmp42_;
					GtkMenuItem* _tmp43_;
					_tmp37_ = _tmp36_;
					if (!_tmp37_) {
						guint _tmp38_;
						_tmp38_ = j;
						j = _tmp38_ + 1;
					}
					_tmp36_ = FALSE;
					_tmp39_ = j;
					_tmp40_ = jsize;
					if (!(_tmp39_ < _tmp40_)) {
						break;
					}
					_tmp41_ = self->priv->menuitems;
					_tmp41__length1 = self->priv->menuitems_length1;
					_tmp42_ = j;
					_tmp43_ = _tmp41_[_tmp42_];
					gtk_widget_destroy (GTK_WIDGET (_tmp43_));
				}
			}
		}
		_tmp44_ = self->priv->menuitems;
		_tmp44__length1 = self->priv->menuitems_length1;
		_tmp45_ = length;
		_tmp46_ = ((_tmp44_ + 0) != NULL) ? _vala_array_dup16 (_tmp44_ + 0, _tmp45_ - 0) : ((gpointer) (_tmp44_ + 0));
		_tmp46__length1 = _tmp45_ - 0;
		self->priv->menuitems = (_vala_array_free (self->priv->menuitems, self->priv->menuitems_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->menuitems = _tmp46_;
		self->priv->menuitems_length1 = _tmp46__length1;
		self->priv->_menuitems_size_ = self->priv->menuitems_length1;
	}
	_tmp47_ = self->priv->menuset;
	if (!_tmp47_) {
		AppIndicator* _tmp48_;
		GtkMenu* _tmp49_;
		AppIndicator* _tmp50_;
		GtkMenu* _tmp51_;
		GList* _tmp52_ = NULL;
		GList* _tmp53_;
		gconstpointer _tmp54_;
		_tmp48_ = self->priv->indicator;
		_tmp49_ = self->priv->_menu;
		app_indicator_set_menu (_tmp48_, _tmp49_);
		_tmp50_ = self->priv->indicator;
		_tmp51_ = self->priv->_menu;
		_tmp52_ = gtk_container_get_children (GTK_CONTAINER (_tmp51_));
		_tmp53_ = _tmp52_;
		_tmp54_ = _tmp53_->data;
		app_indicator_set_secondary_activate_target (_tmp50_, (GtkWidget*) _tmp54_);
		_g_list_free0 (_tmp53_);
		self->priv->menuset = TRUE;
	}
}


static void multi_load_indicator_updatelabelview (MultiLoadIndicator* self) {
	MenuModel* _tmp0_;
	gchar** _tmp1_;
	gint _tmp1__length1;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint indicatorcount;
	gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	gint _tmp5_;
	gboolean _tmp8_;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* indicatorlabel;
	gchar* _tmp17_ = NULL;
	gboolean _tmp18_ = FALSE;
	gint _tmp19_;
	gboolean _tmp22_;
	const gchar* _tmp29_;
	gchar* _tmp30_;
	gchar* indicatorguide;
	AppIndicator* _tmp31_;
	const gchar* _tmp32_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = self->priv->_labelmodel;
	_tmp1_ = menu_model_get_expressions (_tmp0_, &_tmp1__length1);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _tmp1__length1;
	indicatorcount = _tmp2__length1;
	_tmp5_ = self->priv->_indicator_index;
	if (0 <= _tmp5_) {
		gint _tmp6_;
		gint _tmp7_;
		_tmp6_ = self->priv->_indicator_index;
		_tmp7_ = indicatorcount;
		_tmp4_ = _tmp6_ < _tmp7_;
	} else {
		_tmp4_ = FALSE;
	}
	_tmp8_ = _tmp4_;
	if (_tmp8_) {
		MenuModel* _tmp9_;
		gint _tmp10_;
		ExpressionCache* _tmp11_ = NULL;
		ExpressionCache* _tmp12_;
		gchar* _tmp13_ = NULL;
		_tmp9_ = self->priv->_labelmodel;
		_tmp10_ = self->priv->_indicator_index;
		_tmp11_ = menu_model_expression (_tmp9_, (guint) _tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = expression_cache_label (_tmp12_);
		_g_free0 (_tmp3_);
		_tmp3_ = _tmp13_;
		_g_object_unref0 (_tmp12_);
	} else {
		gchar* _tmp14_;
		_tmp14_ = g_strdup ("");
		_g_free0 (_tmp3_);
		_tmp3_ = _tmp14_;
	}
	_tmp15_ = _tmp3_;
	_tmp16_ = g_strdup (_tmp15_);
	indicatorlabel = _tmp16_;
	_tmp19_ = self->priv->_indicator_index;
	if (0 <= _tmp19_) {
		gint _tmp20_;
		gint _tmp21_;
		_tmp20_ = self->priv->_indicator_index;
		_tmp21_ = indicatorcount;
		_tmp18_ = _tmp20_ < _tmp21_;
	} else {
		_tmp18_ = FALSE;
	}
	_tmp22_ = _tmp18_;
	if (_tmp22_) {
		MenuModel* _tmp23_;
		gint _tmp24_;
		ExpressionCache* _tmp25_ = NULL;
		ExpressionCache* _tmp26_;
		gchar* _tmp27_ = NULL;
		_tmp23_ = self->priv->_labelmodel;
		_tmp24_ = self->priv->_indicator_index;
		_tmp25_ = menu_model_expression (_tmp23_, (guint) _tmp24_);
		_tmp26_ = _tmp25_;
		_tmp27_ = expression_cache_guide (_tmp26_);
		_g_free0 (_tmp17_);
		_tmp17_ = _tmp27_;
		_g_object_unref0 (_tmp26_);
	} else {
		gchar* _tmp28_;
		_tmp28_ = g_strdup ("");
		_g_free0 (_tmp17_);
		_tmp17_ = _tmp28_;
	}
	_tmp29_ = _tmp17_;
	_tmp30_ = g_strdup (_tmp29_);
	indicatorguide = _tmp30_;
	_tmp31_ = self->priv->indicator;
	_tmp32_ = indicatorlabel;
	app_indicator_set_label (_tmp31_, _tmp32_, indicatorguide);
	_g_free0 (indicatorguide);
	_g_free0 (_tmp17_);
	_g_free0 (indicatorlabel);
	_g_free0 (_tmp3_);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_object_unref0 (_data1_->self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void ____lambda3_ (Block1Data* _data1_, GtkWidget* w) {
	MultiLoadIndicator * self;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	guint _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	GtkWidget* _tmp5_;
	guint _tmp6_;
	guint _tmp7_;
	guint _tmp8_ = 0U;
	self = _data1_->self;
	g_return_if_fail (GTK_IS_WIDGET (w));
	_tmp0_ = w;
	if (!GTK_IS_IMAGE (_tmp0_)) {
		return;
	}
	_tmp1_ = w;
	_tmp2_ = self->priv->currenticonindex;
	_tmp3_ = multi_load_indicator_iconpath (self, _tmp2_);
	_tmp4_ = _tmp3_;
	gtk_image_set_from_file (GTK_IMAGE (_tmp1_), _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = w;
	_tmp6_ = self->priv->lasticonwidth;
	_tmp7_ = self->priv->_height;
	_tmp8_ = MAX (_tmp6_, _tmp7_);
	gtk_image_set_pixel_size (GTK_IMAGE (_tmp5_), (gint) _tmp8_);
	_data1_->found = TRUE;
}


static void _____lambda3__gtk_callback (GtkWidget* widget, gpointer self) {
	____lambda3_ (self, widget);
}


static void multi_load_indicator_updategraphsview (MultiLoadIndicator* self) {
	Block1Data* _data1_;
	GList* _tmp0_ = NULL;
	gboolean _tmp8_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	multi_load_indicator_iconwrite (self);
	_data1_->found = FALSE;
	_tmp0_ = gtk_window_list_toplevels ();
	{
		GList* toplevel_collection = NULL;
		GList* toplevel_it = NULL;
		toplevel_collection = _tmp0_;
		for (toplevel_it = toplevel_collection; toplevel_it != NULL; toplevel_it = toplevel_it->next) {
			GtkWindow* toplevel = NULL;
			toplevel = (GtkWindow*) toplevel_it->data;
			{
				gboolean _tmp1_ = FALSE;
				GtkWindow* _tmp2_;
				GType _tmp3_ = 0UL;
				const gchar* _tmp4_ = NULL;
				gboolean _tmp6_;
				GtkWindow* _tmp7_;
				_tmp2_ = toplevel;
				_tmp3_ = G_TYPE_FROM_INSTANCE (G_OBJECT (_tmp2_));
				_tmp4_ = g_type_name (_tmp3_);
				if (g_strcmp0 (_tmp4_, "GtkTrayIcon") != 0) {
					_tmp1_ = TRUE;
				} else {
					GtkWindow* _tmp5_;
					_tmp5_ = toplevel;
					_tmp1_ = !GTK_IS_CONTAINER (_tmp5_);
				}
				_tmp6_ = _tmp1_;
				if (_tmp6_) {
					continue;
				}
				_tmp7_ = toplevel;
				gtk_container_foreach (GTK_CONTAINER (_tmp7_), _____lambda3__gtk_callback, _data1_);
			}
		}
		_g_list_free0 (toplevel_collection);
	}
	_tmp8_ = _data1_->found;
	if (!_tmp8_) {
		AppIndicator* _tmp9_;
		guint _tmp10_;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		MenuModel* _tmp13_;
		ExpressionCache* _tmp14_ = NULL;
		ExpressionCache* _tmp15_;
		gchar* _tmp16_ = NULL;
		gchar* _tmp17_;
		_tmp9_ = self->priv->indicator;
		_tmp10_ = self->priv->currenticonindex;
		_tmp11_ = multi_load_indicator_iconname (self, _tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = self->priv->_descriptionmodel;
		_tmp14_ = menu_model_expression (_tmp13_, (guint) 0);
		_tmp15_ = _tmp14_;
		_tmp16_ = expression_cache_label (_tmp15_);
		_tmp17_ = _tmp16_;
		app_indicator_set_icon_full (_tmp9_, _tmp12_, _tmp17_);
		_g_free0 (_tmp17_);
		_g_object_unref0 (_tmp15_);
		_g_free0 (_tmp12_);
	}
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static gchar* multi_load_indicator_iconname (MultiLoadIndicator* self, guint index) {
	gchar* result = NULL;
	guint _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = index;
	_tmp1_ = g_strdup_printf ("%u", _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("indicator-multiload-graphs-", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}


static gchar* multi_load_indicator_iconpath (MultiLoadIndicator* self, guint index) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	guint _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_icondirectory;
	_tmp1_ = index;
	_tmp2_ = multi_load_indicator_iconname (self, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat (_tmp3_, ".png", NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_build_filename (_tmp0_, _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	_g_free0 (_tmp3_);
	result = _tmp7_;
	return result;
}


static void multi_load_indicator_iconwritedummy (MultiLoadIndicator* self) {
	cairo_surface_t* _tmp0_;
	cairo_surface_t* surface;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 1, 1);
	surface = _tmp0_;
	_tmp1_ = multi_load_indicator_iconpath (self, (guint) 0);
	_tmp2_ = _tmp1_;
	cairo_surface_write_to_png (surface, _tmp2_);
	_g_free0 (_tmp2_);
	_tmp3_ = multi_load_indicator_iconpath (self, (guint) 1);
	_tmp4_ = _tmp3_;
	cairo_surface_write_to_png (surface, _tmp4_);
	_g_free0 (_tmp4_);
	_cairo_surface_destroy0 (surface);
}


static TraceModel** _vala_array_dup17 (TraceModel** self, int length) {
	TraceModel** result;
	int i;
	result = g_new0 (TraceModel*, length + 1);
	for (i = 0; i < length; i++) {
		TraceModel* _tmp0_;
		_tmp0_ = _g_object_ref0 (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void multi_load_indicator_iconwrite (MultiLoadIndicator* self) {
	GraphModels* _tmp0_;
	guint count;
	GraphModels* _tmp1_;
	GraphModel** _tmp2_;
	gint _tmp2__length1;
	GraphModel** _tmp3_;
	gint _tmp3__length1;
	guint _tmp9_;
	guint _tmp10_;
	guint _tmp11_;
	guint _tmp12_;
	guint _tmp13_;
	cairo_surface_t* _tmp14_;
	cairo_surface_t* surface;
	cairo_surface_t* _tmp15_;
	cairo_t* _tmp16_;
	cairo_t* ctx;
	cairo_t* _tmp17_;
	cairo_t* _tmp18_;
	guint offset;
	GraphModels* _tmp19_;
	GraphModel** _tmp20_;
	gint _tmp20__length1;
	GraphModel** _tmp21_;
	gint _tmp21__length1;
	guint _tmp122_;
	cairo_surface_t* _tmp123_;
	guint _tmp124_;
	gchar* _tmp125_ = NULL;
	gchar* _tmp126_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	self->priv->lasticonwidth = (guint) 0;
	_tmp0_ = self->priv->_graphmodels;
	if (_tmp0_ == NULL) {
		return;
	}
	count = (guint) 0;
	_tmp1_ = self->priv->_graphmodels;
	_tmp2_ = graph_models_get_graphmodels (_tmp1_, &_tmp2__length1);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _tmp2__length1;
	{
		GraphModel** graphmodel_collection = NULL;
		gint graphmodel_collection_length1 = 0;
		gint _graphmodel_collection_size_ = 0;
		gint graphmodel_it = 0;
		graphmodel_collection = _tmp3_;
		graphmodel_collection_length1 = _tmp3__length1;
		for (graphmodel_it = 0; graphmodel_it < _tmp3__length1; graphmodel_it = graphmodel_it + 1) {
			GraphModel* _tmp4_;
			GraphModel* graphmodel = NULL;
			_tmp4_ = _g_object_ref0 (graphmodel_collection[graphmodel_it]);
			graphmodel = _tmp4_;
			{
				GraphModel* _tmp5_;
				gboolean _tmp6_;
				gboolean _tmp7_;
				_tmp5_ = graphmodel;
				_tmp6_ = graph_model_get_enabled (_tmp5_);
				_tmp7_ = _tmp6_;
				if (_tmp7_) {
					guint _tmp8_;
					_tmp8_ = count;
					count = _tmp8_ + 1;
				}
				_g_object_unref0 (graphmodel);
			}
		}
	}
	_tmp9_ = count;
	if (_tmp9_ == ((guint) 0)) {
		return;
	}
	_tmp10_ = count;
	_tmp11_ = self->priv->_width;
	self->priv->lasticonwidth = (guint) (((gint) (_tmp10_ * (_tmp11_ + 2))) - 2);
	_tmp12_ = self->priv->lasticonwidth;
	_tmp13_ = self->priv->_height;
	_tmp14_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, (gint) _tmp12_, (gint) _tmp13_);
	surface = _tmp14_;
	_tmp15_ = surface;
	_tmp16_ = cairo_create (_tmp15_);
	ctx = _tmp16_;
	_tmp17_ = ctx;
	cairo_set_antialias (_tmp17_, CAIRO_ANTIALIAS_NONE);
	_tmp18_ = ctx;
	cairo_set_line_width (_tmp18_, (gdouble) 1);
	offset = (guint) 0;
	_tmp19_ = self->priv->_graphmodels;
	_tmp20_ = graph_models_get_graphmodels (_tmp19_, &_tmp20__length1);
	_tmp21_ = _tmp20_;
	_tmp21__length1 = _tmp20__length1;
	{
		GraphModel** graphmodel_collection = NULL;
		gint graphmodel_collection_length1 = 0;
		gint _graphmodel_collection_size_ = 0;
		gint graphmodel_it = 0;
		graphmodel_collection = _tmp21_;
		graphmodel_collection_length1 = _tmp21__length1;
		for (graphmodel_it = 0; graphmodel_it < _tmp21__length1; graphmodel_it = graphmodel_it + 1) {
			GraphModel* _tmp22_;
			GraphModel* graphmodel = NULL;
			_tmp22_ = _g_object_ref0 (graphmodel_collection[graphmodel_it]);
			graphmodel = _tmp22_;
			{
				GraphModel* _tmp23_;
				gboolean _tmp24_;
				gboolean _tmp25_;
				GraphModel* _tmp26_;
				cairo_t* _tmp27_;
				cairo_t* _tmp28_;
				guint _tmp29_;
				guint _tmp30_;
				guint _tmp31_;
				cairo_t* _tmp32_;
				GraphModel* _tmp33_;
				TraceModel** _tmp34_;
				gint _tmp34__length1;
				TraceModel** _tmp35_;
				gint _tmp35__length1;
				TraceModel** _tmp36_;
				gint _tmp36__length1;
				TraceModel** tracemodels;
				gint tracemodels_length1;
				gint _tracemodels_size_;
				TraceModel** _tmp37_;
				gint _tmp37__length1;
				guint _tmp38_;
				gdouble* _tmp39_ = NULL;
				gdouble* values;
				gint values_length1;
				gint values_length2;
				GraphModel* _tmp40_;
				gdouble _tmp41_;
				gdouble _tmp42_;
				gdouble scale;
				guint _tmp120_;
				guint _tmp121_;
				_tmp23_ = graphmodel;
				_tmp24_ = graph_model_get_enabled (_tmp23_);
				_tmp25_ = _tmp24_;
				if (!_tmp25_) {
					_g_object_unref0 (graphmodel);
					continue;
				}
				_tmp26_ = graphmodel;
				_tmp27_ = ctx;
				graph_model_set_source_color (_tmp26_, _tmp27_);
				_tmp28_ = ctx;
				_tmp29_ = offset;
				_tmp30_ = self->priv->_width;
				_tmp31_ = self->priv->_height;
				cairo_rectangle (_tmp28_, (gdouble) _tmp29_, (gdouble) 0, (gdouble) _tmp30_, (gdouble) _tmp31_);
				_tmp32_ = ctx;
				cairo_fill (_tmp32_);
				_tmp33_ = graphmodel;
				_tmp34_ = graph_model_get_tracemodels (_tmp33_, &_tmp34__length1);
				_tmp35_ = _tmp34_;
				_tmp35__length1 = _tmp34__length1;
				_tmp36_ = (_tmp35_ != NULL) ? _vala_array_dup17 (_tmp35_, _tmp35__length1) : ((gpointer) _tmp35_);
				_tmp36__length1 = _tmp35__length1;
				tracemodels = _tmp36_;
				tracemodels_length1 = _tmp36__length1;
				_tracemodels_size_ = tracemodels_length1;
				_tmp37_ = tracemodels;
				_tmp37__length1 = tracemodels_length1;
				_tmp38_ = self->priv->_width;
				_tmp39_ = g_new0 (gdouble, _tmp37__length1 * _tmp38_);
				values = _tmp39_;
				values_length1 = _tmp37__length1;
				values_length2 = _tmp38_;
				_tmp40_ = graphmodel;
				_tmp41_ = graph_model_get_scale (_tmp40_);
				_tmp42_ = _tmp41_;
				scale = _tmp42_;
				{
					guint j;
					gdouble* _tmp43_;
					gint _tmp43__length1;
					gint _tmp43__length2;
					gint _tmp44_;
					guint jsize;
					j = (guint) 0;
					_tmp43_ = values;
					_tmp43__length1 = values_length1;
					_tmp43__length2 = values_length2;
					_tmp44_ = _tmp43__length1;
					jsize = (guint) _tmp44_;
					{
						gboolean _tmp45_;
						_tmp45_ = TRUE;
						while (TRUE) {
							gboolean _tmp46_;
							guint _tmp48_;
							guint _tmp49_;
							TraceModel** _tmp50_;
							gint _tmp50__length1;
							guint _tmp51_;
							TraceModel* _tmp52_;
							gboolean _tmp53_;
							gboolean _tmp54_;
							gboolean enabled;
							TraceModel** _tmp55_;
							gint _tmp55__length1;
							guint _tmp56_;
							TraceModel* _tmp57_;
							gdouble* _tmp58_;
							gint _tmp58__length1;
							gdouble* _tmp59_;
							gint _tmp59__length1;
							gdouble* tracedata;
							gint tracedata_length1;
							gint _tracedata_size_;
							_tmp46_ = _tmp45_;
							if (!_tmp46_) {
								guint _tmp47_;
								_tmp47_ = j;
								j = _tmp47_ + 1;
							}
							_tmp45_ = FALSE;
							_tmp48_ = j;
							_tmp49_ = jsize;
							if (!(_tmp48_ < _tmp49_)) {
								break;
							}
							_tmp50_ = tracemodels;
							_tmp50__length1 = tracemodels_length1;
							_tmp51_ = j;
							_tmp52_ = _tmp50_[_tmp51_];
							_tmp53_ = trace_model_get_enabled (_tmp52_);
							_tmp54_ = _tmp53_;
							enabled = _tmp54_;
							_tmp55_ = tracemodels;
							_tmp55__length1 = tracemodels_length1;
							_tmp56_ = j;
							_tmp57_ = _tmp55_[_tmp56_];
							_tmp58_ = trace_model_get_values (_tmp57_, &_tmp58__length1);
							_tmp59_ = _tmp58_;
							_tmp59__length1 = _tmp58__length1;
							tracedata = _tmp59_;
							tracedata_length1 = _tmp59__length1;
							_tracedata_size_ = tracedata_length1;
							{
								guint i;
								gdouble* _tmp60_;
								gint _tmp60__length1;
								gint _tmp60__length2;
								gint _tmp61_;
								guint isize;
								i = (guint) 0;
								_tmp60_ = values;
								_tmp60__length1 = values_length1;
								_tmp60__length2 = values_length2;
								_tmp61_ = _tmp60__length2;
								isize = (guint) _tmp61_;
								{
									gboolean _tmp62_;
									_tmp62_ = TRUE;
									while (TRUE) {
										gboolean _tmp63_;
										guint _tmp65_;
										guint _tmp66_;
										gdouble _tmp67_ = 0.0;
										guint _tmp68_;
										gdouble _tmp73_ = 0.0;
										gboolean _tmp74_;
										gdouble* _tmp78_;
										gint _tmp78__length1;
										gint _tmp78__length2;
										guint _tmp79_;
										guint _tmp80_;
										gdouble _tmp81_;
										gdouble _tmp82_;
										gdouble _tmp83_;
										gdouble _tmp84_;
										_tmp63_ = _tmp62_;
										if (!_tmp63_) {
											guint _tmp64_;
											_tmp64_ = i;
											i = _tmp64_ + 1;
										}
										_tmp62_ = FALSE;
										_tmp65_ = i;
										_tmp66_ = isize;
										if (!(_tmp65_ < _tmp66_)) {
											break;
										}
										_tmp68_ = j;
										if (_tmp68_ > ((guint) 0)) {
											gdouble* _tmp69_;
											gint _tmp69__length1;
											gint _tmp69__length2;
											guint _tmp70_;
											guint _tmp71_;
											gdouble _tmp72_;
											_tmp69_ = values;
											_tmp69__length1 = values_length1;
											_tmp69__length2 = values_length2;
											_tmp70_ = j;
											_tmp71_ = i;
											_tmp72_ = _tmp69_[((_tmp70_ - 1) * _tmp69__length2) + _tmp71_];
											_tmp67_ = _tmp72_;
										} else {
											_tmp67_ = (gdouble) 0;
										}
										_tmp74_ = enabled;
										if (_tmp74_) {
											gdouble* _tmp75_;
											gint _tmp75__length1;
											guint _tmp76_;
											gdouble _tmp77_;
											_tmp75_ = tracedata;
											_tmp75__length1 = tracedata_length1;
											_tmp76_ = i;
											_tmp77_ = _tmp75_[_tmp76_];
											_tmp73_ = _tmp77_;
										} else {
											_tmp73_ = (gdouble) 0;
										}
										_tmp78_ = values;
										_tmp78__length1 = values_length1;
										_tmp78__length2 = values_length2;
										_tmp79_ = j;
										_tmp80_ = i;
										_tmp81_ = _tmp67_;
										_tmp82_ = _tmp73_;
										_tmp83_ = scale;
										_tmp78_[(_tmp79_ * _tmp78__length2) + _tmp80_] = _tmp81_ + (_tmp82_ / _tmp83_);
										_tmp84_ = _tmp78_[(_tmp79_ * _tmp78__length2) + _tmp80_];
									}
								}
							}
						}
					}
				}
				{
					gdouble* _tmp85_;
					gint _tmp85__length1;
					gint _tmp85__length2;
					gint _tmp86_;
					gint j;
					_tmp85_ = values;
					_tmp85__length1 = values_length1;
					_tmp85__length2 = values_length2;
					_tmp86_ = _tmp85__length1;
					j = _tmp86_ - 1;
					{
						gboolean _tmp87_;
						_tmp87_ = TRUE;
						while (TRUE) {
							gboolean _tmp88_;
							gint _tmp90_;
							cairo_t* _tmp91_;
							GraphModel* _tmp92_;
							TraceModel** _tmp93_;
							gint _tmp93__length1;
							TraceModel** _tmp94_;
							gint _tmp94__length1;
							gint _tmp95_;
							TraceModel* _tmp96_;
							GdkColor _tmp97_;
							GdkColor _tmp98_;
							cairo_t* _tmp119_;
							_tmp88_ = _tmp87_;
							if (!_tmp88_) {
								gint _tmp89_;
								_tmp89_ = j;
								j = _tmp89_ - 1;
							}
							_tmp87_ = FALSE;
							_tmp90_ = j;
							if (!(_tmp90_ >= 0)) {
								break;
							}
							_tmp91_ = ctx;
							_tmp92_ = graphmodel;
							_tmp93_ = graph_model_get_tracemodels (_tmp92_, &_tmp93__length1);
							_tmp94_ = _tmp93_;
							_tmp94__length1 = _tmp93__length1;
							_tmp95_ = j;
							_tmp96_ = _tmp94_[_tmp95_];
							trace_model_get_color (_tmp96_, &_tmp97_);
							_tmp98_ = _tmp97_;
							gdk_cairo_set_source_color (_tmp91_, &_tmp98_);
							{
								guint i;
								gdouble* _tmp99_;
								gint _tmp99__length1;
								gint _tmp99__length2;
								gint _tmp100_;
								guint isize;
								i = (guint) 0;
								_tmp99_ = values;
								_tmp99__length1 = values_length1;
								_tmp99__length2 = values_length2;
								_tmp100_ = _tmp99__length2;
								isize = (guint) _tmp100_;
								{
									gboolean _tmp101_;
									_tmp101_ = TRUE;
									while (TRUE) {
										gboolean _tmp102_;
										guint _tmp104_;
										guint _tmp105_;
										cairo_t* _tmp106_;
										guint _tmp107_;
										guint _tmp108_;
										guint _tmp109_;
										cairo_t* _tmp110_;
										guint _tmp111_;
										guint _tmp112_;
										guint _tmp113_;
										guint _tmp114_;
										gdouble* _tmp115_;
										gint _tmp115__length1;
										gint _tmp115__length2;
										gint _tmp116_;
										guint _tmp117_;
										gdouble _tmp118_;
										_tmp102_ = _tmp101_;
										if (!_tmp102_) {
											guint _tmp103_;
											_tmp103_ = i;
											i = _tmp103_ + 1;
										}
										_tmp101_ = FALSE;
										_tmp104_ = i;
										_tmp105_ = isize;
										if (!(_tmp104_ < _tmp105_)) {
											break;
										}
										_tmp106_ = ctx;
										_tmp107_ = offset;
										_tmp108_ = i;
										_tmp109_ = self->priv->_height;
										cairo_move_to (_tmp106_, (0.5 + _tmp107_) + _tmp108_, _tmp109_ + 0.5);
										_tmp110_ = ctx;
										_tmp111_ = offset;
										_tmp112_ = i;
										_tmp113_ = self->priv->_height;
										_tmp114_ = self->priv->_height;
										_tmp115_ = values;
										_tmp115__length1 = values_length1;
										_tmp115__length2 = values_length2;
										_tmp116_ = j;
										_tmp117_ = i;
										_tmp118_ = _tmp115_[(_tmp116_ * _tmp115__length2) + _tmp117_];
										cairo_line_to (_tmp110_, (0.5 + _tmp111_) + _tmp112_, (_tmp113_ + 0.5) - (_tmp114_ * _tmp118_));
									}
								}
							}
							_tmp119_ = ctx;
							cairo_stroke (_tmp119_);
						}
					}
				}
				_tmp120_ = offset;
				_tmp121_ = self->priv->_width;
				offset = _tmp120_ + (_tmp121_ + 2);
				values = (g_free (values), NULL);
				tracemodels = (_vala_array_free (tracemodels, tracemodels_length1, (GDestroyNotify) g_object_unref), NULL);
				_g_object_unref0 (graphmodel);
			}
		}
	}
	_tmp122_ = self->priv->currenticonindex;
	self->priv->currenticonindex = 1 - _tmp122_;
	_tmp123_ = surface;
	_tmp124_ = self->priv->currenticonindex;
	_tmp125_ = multi_load_indicator_iconpath (self, _tmp124_);
	_tmp126_ = _tmp125_;
	cairo_surface_write_to_png (_tmp123_, _tmp126_);
	_g_free0 (_tmp126_);
	_cairo_destroy0 (ctx);
	_cairo_surface_destroy0 (surface);
}


const gchar* multi_load_indicator_get_icondirectory (MultiLoadIndicator* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_icondirectory;
	result = _tmp0_;
	return result;
}


static void multi_load_indicator_set_icondirectory (MultiLoadIndicator* self, const gchar* value) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_icondirectory);
	self->priv->_icondirectory = _tmp1_;
	g_object_notify ((GObject *) self, "icondirectory");
}


Providers* multi_load_indicator_get_providers (MultiLoadIndicator* self) {
	Providers* result;
	Providers* _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_providers;
	result = _tmp0_;
	return result;
}


static void multi_load_indicator_set_providers (MultiLoadIndicator* self, Providers* value) {
	Providers* _tmp0_;
	Providers* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_providers);
	self->priv->_providers = _tmp1_;
	g_object_notify ((GObject *) self, "providers");
}


MenuModel* multi_load_indicator_get_menumodel (MultiLoadIndicator* self) {
	MenuModel* result;
	MenuModel* _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_menumodel;
	result = _tmp0_;
	return result;
}


static void multi_load_indicator_set_menumodel (MultiLoadIndicator* self, MenuModel* value) {
	MenuModel* _tmp0_;
	MenuModel* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_menumodel);
	self->priv->_menumodel = _tmp1_;
	g_object_notify ((GObject *) self, "menumodel");
}


MenuModel* multi_load_indicator_get_labelmodel (MultiLoadIndicator* self) {
	MenuModel* result;
	MenuModel* _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_labelmodel;
	result = _tmp0_;
	return result;
}


static void multi_load_indicator_set_labelmodel (MultiLoadIndicator* self, MenuModel* value) {
	MenuModel* _tmp0_;
	MenuModel* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_labelmodel);
	self->priv->_labelmodel = _tmp1_;
	g_object_notify ((GObject *) self, "labelmodel");
}


MenuModel* multi_load_indicator_get_descriptionmodel (MultiLoadIndicator* self) {
	MenuModel* result;
	MenuModel* _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_descriptionmodel;
	result = _tmp0_;
	return result;
}


static void multi_load_indicator_set_descriptionmodel (MultiLoadIndicator* self, MenuModel* value) {
	MenuModel* _tmp0_;
	MenuModel* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_descriptionmodel);
	self->priv->_descriptionmodel = _tmp1_;
	g_object_notify ((GObject *) self, "descriptionmodel");
}


gint multi_load_indicator_get_indicator_index (MultiLoadIndicator* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), 0);
	_tmp0_ = self->priv->_indicator_index;
	result = _tmp0_;
	return result;
}


void multi_load_indicator_set_indicator_index (MultiLoadIndicator* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	self->priv->_indicator_index = _tmp0_;
	g_object_notify ((GObject *) self, "indicator-index");
}


guint multi_load_indicator_get_height (MultiLoadIndicator* self) {
	guint result;
	guint _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), 0U);
	_tmp0_ = self->priv->_height;
	result = _tmp0_;
	return result;
}


void multi_load_indicator_set_height (MultiLoadIndicator* self, guint value) {
	guint _tmp0_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	self->priv->_height = _tmp0_;
	g_object_notify ((GObject *) self, "height");
}


guint multi_load_indicator_get_width (MultiLoadIndicator* self) {
	guint result;
	guint _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), 0U);
	_tmp0_ = self->priv->_width;
	result = _tmp0_;
	return result;
}


void multi_load_indicator_set_width (MultiLoadIndicator* self, guint value) {
	guint _tmp0_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	self->priv->_width = _tmp0_;
	g_object_notify ((GObject *) self, "width");
}


guint multi_load_indicator_get_speed (MultiLoadIndicator* self) {
	guint result;
	guint _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), 0U);
	_tmp0_ = self->priv->_speed;
	result = _tmp0_;
	return result;
}


void multi_load_indicator_set_speed (MultiLoadIndicator* self, guint value) {
	guint _tmp0_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	self->priv->_speed = _tmp0_;
	g_object_notify ((GObject *) self, "speed");
}


GtkMenu* multi_load_indicator_get_menu (MultiLoadIndicator* self) {
	GtkMenu* result;
	GtkMenu* _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_menu;
	result = _tmp0_;
	return result;
}


void multi_load_indicator_set_menu (MultiLoadIndicator* self, GtkMenu* value) {
	GtkMenu* _tmp0_;
	GtkMenu* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_menu);
	self->priv->_menu = _tmp1_;
	g_object_notify ((GObject *) self, "menu");
}


GraphModels* multi_load_indicator_get_graphmodels (MultiLoadIndicator* self) {
	GraphModels* result;
	GraphModels* _tmp0_;
	g_return_val_if_fail (IS_MULTI_LOAD_INDICATOR (self), NULL);
	_tmp0_ = self->priv->_graphmodels;
	result = _tmp0_;
	return result;
}


void multi_load_indicator_set_graphmodels (MultiLoadIndicator* self, GraphModels* value) {
	GraphModels* _tmp0_;
	GraphModels* _tmp1_;
	g_return_if_fail (IS_MULTI_LOAD_INDICATOR (self));
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_graphmodels);
	self->priv->_graphmodels = _tmp1_;
	g_object_notify ((GObject *) self, "graphmodels");
}


static void _multi_load_indicator___lambda4_ (MultiLoadIndicator* self, gint delta, guint direction) {
	gint _tmp0_;
	gint index;
	guint _tmp1_;
	gint _tmp7_;
	MenuModel* _tmp8_;
	gchar** _tmp9_;
	gint _tmp9__length1;
	gchar** _tmp10_;
	gint _tmp10__length1;
	gint _tmp14_;
	gint _tmp15_;
	_tmp0_ = self->priv->_indicator_index;
	index = _tmp0_;
	_tmp1_ = direction;
	if (_tmp1_ == ((guint) GDK_SCROLL_DOWN)) {
		gint _tmp2_;
		gint _tmp3_;
		_tmp2_ = index;
		_tmp3_ = delta;
		index = _tmp2_ + _tmp3_;
	} else {
		guint _tmp4_;
		_tmp4_ = direction;
		if (_tmp4_ == ((guint) GDK_SCROLL_UP)) {
			gint _tmp5_;
			gint _tmp6_;
			_tmp5_ = index;
			_tmp6_ = delta;
			index = _tmp5_ - _tmp6_;
		}
	}
	_tmp7_ = index;
	_tmp8_ = self->priv->_labelmodel;
	_tmp9_ = menu_model_get_expressions (_tmp8_, &_tmp9__length1);
	_tmp10_ = _tmp9_;
	_tmp10__length1 = _tmp9__length1;
	if (_tmp7_ >= _tmp10__length1) {
		MenuModel* _tmp11_;
		gchar** _tmp12_;
		gint _tmp12__length1;
		gchar** _tmp13_;
		gint _tmp13__length1;
		_tmp11_ = self->priv->_labelmodel;
		_tmp12_ = menu_model_get_expressions (_tmp11_, &_tmp12__length1);
		_tmp13_ = _tmp12_;
		_tmp13__length1 = _tmp12__length1;
		index = _tmp13__length1 - 1;
	}
	_tmp14_ = index;
	if (_tmp14_ < 0) {
		index = 0;
	}
	_tmp15_ = index;
	multi_load_indicator_set_indicator_index (self, _tmp15_);
}


static void __multi_load_indicator___lambda4__app_indicator_scroll_event (AppIndicator* _sender, gint delta, guint direction, gpointer self) {
	_multi_load_indicator___lambda4_ (self, delta, direction);
}


static void _multi_load_indicator___lambda5_ (MultiLoadIndicator* self) {
	AppIndicator* _tmp0_;
	AppIndicatorStatus _tmp1_ = 0;
	_tmp0_ = self->priv->indicator;
	_tmp1_ = app_indicator_get_status (_tmp0_);
	if (_tmp1_ == APP_INDICATOR_STATUS_ACTIVE) {
		multi_load_indicator_updateviews (self);
	}
}


static void __multi_load_indicator___lambda5__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_multi_load_indicator___lambda5_ (self);
}


static gboolean __lambda7_ (MultiLoadIndicator* self) {
	gboolean result = FALSE;
	multi_load_indicator_updateall (self);
	result = TRUE;
	return result;
}


static gboolean ___lambda7__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda7_ (self);
	return result;
}


static void _multi_load_indicator___lambda6_ (MultiLoadIndicator* self) {
	GSource* _tmp0_;
	guint _tmp2_;
	guint _tmp3_;
	GSource* _tmp8_;
	GSource* _tmp9_;
	_tmp0_ = self->priv->timeout;
	if (_tmp0_ != NULL) {
		GSource* _tmp1_;
		_tmp1_ = self->priv->timeout;
		g_source_destroy (_tmp1_);
	}
	_tmp2_ = self->priv->_speed;
	if (_tmp2_ == ((guint) 0)) {
		_g_source_unref0 (self->priv->timeout);
		self->priv->timeout = NULL;
		return;
	}
	_tmp3_ = self->priv->_speed;
	if ((_tmp3_ % 1000) == ((guint) 0)) {
		guint _tmp4_;
		GSource* _tmp5_;
		_tmp4_ = self->priv->_speed;
		_tmp5_ = g_timeout_source_new_seconds (_tmp4_ / 1000);
		_g_source_unref0 (self->priv->timeout);
		self->priv->timeout = _tmp5_;
	} else {
		guint _tmp6_;
		GSource* _tmp7_;
		_tmp6_ = self->priv->_speed;
		_tmp7_ = g_timeout_source_new (_tmp6_);
		_g_source_unref0 (self->priv->timeout);
		self->priv->timeout = _tmp7_;
	}
	_tmp8_ = self->priv->timeout;
	g_source_attach (_tmp8_, NULL);
	_tmp9_ = self->priv->timeout;
	g_source_set_callback (_tmp9_, ___lambda7__gsource_func, g_object_ref (self), g_object_unref);
}


static void __multi_load_indicator___lambda6__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	_multi_load_indicator___lambda6_ (self);
}


static GObject * multi_load_indicator_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	MultiLoadIndicator * self;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	AppIndicator* _tmp2_;
	AppIndicator* _tmp3_;
	parent_class = G_OBJECT_CLASS (multi_load_indicator_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = MULTI_LOAD_INDICATOR (obj);
	_tmp0_ = self->priv->_icondirectory;
	g_mkdir (_tmp0_, 0777);
	multi_load_indicator_iconwritedummy (self);
	_tmp1_ = self->priv->_icondirectory;
	_tmp2_ = app_indicator_new_with_path ("multiload", "", APP_INDICATOR_CATEGORY_SYSTEM_SERVICES, _tmp1_);
	_g_object_unref0 (self->priv->indicator);
	self->priv->indicator = _tmp2_;
	_tmp3_ = self->priv->indicator;
	g_signal_connect_object (_tmp3_, "scroll-event", (GCallback) __multi_load_indicator___lambda4__app_indicator_scroll_event, self, 0);
	g_signal_connect_object (G_OBJECT (self), "notify::indicator-index", (GCallback) __multi_load_indicator___lambda5__g_object_notify, self, 0);
	g_signal_connect_object (G_OBJECT (self), "notify::speed", (GCallback) __multi_load_indicator___lambda6__g_object_notify, self, 0);
	return obj;
}


static void multi_load_indicator_class_init (MultiLoadIndicatorClass * klass) {
	multi_load_indicator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MultiLoadIndicatorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_multi_load_indicator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_multi_load_indicator_set_property;
	G_OBJECT_CLASS (klass)->constructor = multi_load_indicator_constructor;
	G_OBJECT_CLASS (klass)->finalize = multi_load_indicator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_ICONDIRECTORY, g_param_spec_string ("icondirectory", "icondirectory", "icondirectory", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_PROVIDERS, g_param_spec_object ("providers", "providers", "providers", TYPE_PROVIDERS, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_MENUMODEL, g_param_spec_object ("menumodel", "menumodel", "menumodel", TYPE_MENU_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_LABELMODEL, g_param_spec_object ("labelmodel", "labelmodel", "labelmodel", TYPE_MENU_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_DESCRIPTIONMODEL, g_param_spec_object ("descriptionmodel", "descriptionmodel", "descriptionmodel", TYPE_MENU_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_INDICATOR_INDEX, g_param_spec_int ("indicator-index", "indicator-index", "indicator-index", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_HEIGHT, g_param_spec_uint ("height", "height", "height", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_WIDTH, g_param_spec_uint ("width", "width", "width", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_SPEED, g_param_spec_uint ("speed", "speed", "speed", 0, G_MAXUINT, 0U, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_MENU, g_param_spec_object ("menu", "menu", "menu", GTK_TYPE_MENU, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MULTI_LOAD_INDICATOR_GRAPHMODELS, g_param_spec_object ("graphmodels", "graphmodels", "graphmodels", TYPE_GRAPH_MODELS, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void multi_load_indicator_instance_init (MultiLoadIndicator * self) {
	self->priv = MULTI_LOAD_INDICATOR_GET_PRIVATE (self);
}


static void multi_load_indicator_finalize (GObject* obj) {
	MultiLoadIndicator * self;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	self = MULTI_LOAD_INDICATOR (obj);
	_tmp0_ = multi_load_indicator_iconpath (self, (guint) 0);
	_tmp1_ = _tmp0_;
	g_remove (_tmp1_);
	_g_free0 (_tmp1_);
	_tmp2_ = multi_load_indicator_iconpath (self, (guint) 1);
	_tmp3_ = _tmp2_;
	g_remove (_tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = self->priv->_icondirectory;
	g_rmdir (_tmp4_);
	_g_source_unref0 (self->priv->timeout);
	_g_object_unref0 (self->priv->indicator);
	self->priv->menuitems = (_vala_array_free (self->priv->menuitems, self->priv->menuitems_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_free0 (self->priv->_icondirectory);
	_g_object_unref0 (self->priv->_providers);
	_g_object_unref0 (self->priv->_menumodel);
	_g_object_unref0 (self->priv->_labelmodel);
	_g_object_unref0 (self->priv->_descriptionmodel);
	_g_object_unref0 (self->priv->_menu);
	_g_object_unref0 (self->priv->_graphmodels);
	G_OBJECT_CLASS (multi_load_indicator_parent_class)->finalize (obj);
}


/******************************************************************************
 * Copyright (C) 2011  Michael Hofmann <mh21@piware.de>                       *
 *                                                                            *
 * This program is free software; you can redistribute it and/or modify       *
 * it under the terms of the GNU General Public License as published by       *
 * the Free Software Foundation; either version 3 of the License, or          *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU General Public License for more details.                               *
 *                                                                            *
 * You should have received a copy of the GNU General Public License along    *
 * with this program; if not, write to the Free Software Foundation, Inc.,    *
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.                *
 ******************************************************************************/
GType multi_load_indicator_get_type (void) {
	static volatile gsize multi_load_indicator_type_id__volatile = 0;
	if (g_once_init_enter (&multi_load_indicator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MultiLoadIndicatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) multi_load_indicator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MultiLoadIndicator), 0, (GInstanceInitFunc) multi_load_indicator_instance_init, NULL };
		GType multi_load_indicator_type_id;
		multi_load_indicator_type_id = g_type_register_static (G_TYPE_OBJECT, "MultiLoadIndicator", &g_define_type_info, 0);
		g_once_init_leave (&multi_load_indicator_type_id__volatile, multi_load_indicator_type_id);
	}
	return multi_load_indicator_type_id__volatile;
}


static void _vala_multi_load_indicator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	MultiLoadIndicator * self;
	self = MULTI_LOAD_INDICATOR (object);
	switch (property_id) {
		case MULTI_LOAD_INDICATOR_ICONDIRECTORY:
		g_value_set_string (value, multi_load_indicator_get_icondirectory (self));
		break;
		case MULTI_LOAD_INDICATOR_PROVIDERS:
		g_value_set_object (value, multi_load_indicator_get_providers (self));
		break;
		case MULTI_LOAD_INDICATOR_MENUMODEL:
		g_value_set_object (value, multi_load_indicator_get_menumodel (self));
		break;
		case MULTI_LOAD_INDICATOR_LABELMODEL:
		g_value_set_object (value, multi_load_indicator_get_labelmodel (self));
		break;
		case MULTI_LOAD_INDICATOR_DESCRIPTIONMODEL:
		g_value_set_object (value, multi_load_indicator_get_descriptionmodel (self));
		break;
		case MULTI_LOAD_INDICATOR_INDICATOR_INDEX:
		g_value_set_int (value, multi_load_indicator_get_indicator_index (self));
		break;
		case MULTI_LOAD_INDICATOR_HEIGHT:
		g_value_set_uint (value, multi_load_indicator_get_height (self));
		break;
		case MULTI_LOAD_INDICATOR_WIDTH:
		g_value_set_uint (value, multi_load_indicator_get_width (self));
		break;
		case MULTI_LOAD_INDICATOR_SPEED:
		g_value_set_uint (value, multi_load_indicator_get_speed (self));
		break;
		case MULTI_LOAD_INDICATOR_MENU:
		g_value_set_object (value, multi_load_indicator_get_menu (self));
		break;
		case MULTI_LOAD_INDICATOR_GRAPHMODELS:
		g_value_set_object (value, multi_load_indicator_get_graphmodels (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_multi_load_indicator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	MultiLoadIndicator * self;
	self = MULTI_LOAD_INDICATOR (object);
	switch (property_id) {
		case MULTI_LOAD_INDICATOR_ICONDIRECTORY:
		multi_load_indicator_set_icondirectory (self, g_value_get_string (value));
		break;
		case MULTI_LOAD_INDICATOR_PROVIDERS:
		multi_load_indicator_set_providers (self, g_value_get_object (value));
		break;
		case MULTI_LOAD_INDICATOR_MENUMODEL:
		multi_load_indicator_set_menumodel (self, g_value_get_object (value));
		break;
		case MULTI_LOAD_INDICATOR_LABELMODEL:
		multi_load_indicator_set_labelmodel (self, g_value_get_object (value));
		break;
		case MULTI_LOAD_INDICATOR_DESCRIPTIONMODEL:
		multi_load_indicator_set_descriptionmodel (self, g_value_get_object (value));
		break;
		case MULTI_LOAD_INDICATOR_INDICATOR_INDEX:
		multi_load_indicator_set_indicator_index (self, g_value_get_int (value));
		break;
		case MULTI_LOAD_INDICATOR_HEIGHT:
		multi_load_indicator_set_height (self, g_value_get_uint (value));
		break;
		case MULTI_LOAD_INDICATOR_WIDTH:
		multi_load_indicator_set_width (self, g_value_get_uint (value));
		break;
		case MULTI_LOAD_INDICATOR_SPEED:
		multi_load_indicator_set_speed (self, g_value_get_uint (value));
		break;
		case MULTI_LOAD_INDICATOR_MENU:
		multi_load_indicator_set_menu (self, g_value_get_object (value));
		break;
		case MULTI_LOAD_INDICATOR_GRAPHMODELS:
		multi_load_indicator_set_graphmodels (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



