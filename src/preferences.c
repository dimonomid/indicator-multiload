/* preferences.c generated by valac 0.14.2, the Vala compiler
 * generated from preferences.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>


#define TYPE_PREFERENCES (preferences_get_type ())
#define PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PREFERENCES, Preferences))
#define PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PREFERENCES, PreferencesClass))
#define IS_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PREFERENCES))
#define IS_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PREFERENCES))
#define PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PREFERENCES, PreferencesClass))

typedef struct _Preferences Preferences;
typedef struct _PreferencesClass PreferencesClass;
typedef struct _PreferencesPrivate PreferencesPrivate;

#define TYPE_ITEM_PREFERENCES (item_preferences_get_type ())
#define ITEM_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ITEM_PREFERENCES, ItemPreferences))
#define ITEM_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ITEM_PREFERENCES, ItemPreferencesClass))
#define IS_ITEM_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ITEM_PREFERENCES))
#define IS_ITEM_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ITEM_PREFERENCES))
#define ITEM_PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ITEM_PREFERENCES, ItemPreferencesClass))

typedef struct _ItemPreferences ItemPreferences;
typedef struct _ItemPreferencesClass ItemPreferencesClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_SETTINGS_CACHE (settings_cache_get_type ())
#define SETTINGS_CACHE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_CACHE, SettingsCache))
#define SETTINGS_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_CACHE, SettingsCacheClass))
#define IS_SETTINGS_CACHE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_CACHE))
#define IS_SETTINGS_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_CACHE))
#define SETTINGS_CACHE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_CACHE, SettingsCacheClass))

typedef struct _SettingsCache SettingsCache;
typedef struct _SettingsCacheClass SettingsCacheClass;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _Preferences {
	GObject parent_instance;
	PreferencesPrivate * priv;
};

struct _PreferencesClass {
	GObjectClass parent_class;
};

struct _PreferencesPrivate {
	GtkDialog* preferences;
	ItemPreferences* menupreferences;
	ItemPreferences* indicatorpreferences;
};


static gpointer preferences_parent_class = NULL;

GType preferences_get_type (void) G_GNUC_CONST;
GType item_preferences_get_type (void) G_GNUC_CONST;
#define PREFERENCES_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PREFERENCES, PreferencesPrivate))
enum  {
	PREFERENCES_DUMMY_PROPERTY
};
void preferences_show (Preferences* self);
GObject* utils_get_ui (const gchar* objectid, GObject* signalhandlers, gchar** additional, int additional_length1, GtkBuilder** builder);
SettingsCache* settings_cache_new (void);
SettingsCache* settings_cache_construct (GType object_type);
GType settings_cache_get_type (void) G_GNUC_CONST;
GSettings* settings_cache_generalsettings (SettingsCache* self);
static gboolean _vala_string_array_contains (const gchar** stack, int stack_length, const gchar* needle);
GSettings* settings_cache_graphsettings (SettingsCache* self, const gchar* graphid);
GSettings* settings_cache_tracesettings (SettingsCache* self, const gchar* graphid, const gchar* traceid);
gboolean utils_get_settings_color (GValue* value, GVariant* variant, void* user_data);
static gboolean _utils_get_settings_color_gsettings_bind_get_mapping (GValue* value, GVariant* variant, void* user_data);
GVariant* utils_set_settings_color (GValue* value, const GVariantType* expected_type, void* user_data);
static GVariant* _utils_set_settings_color_gsettings_bind_set_mapping (GValue* value, const GVariantType* expected_type, void* user_data);
static void _______lambda8_ (void);
static void ________lambda8__gdestroy_notify (void* data);
static void ____lambda9_ (void);
static void _____lambda9__gdestroy_notify (void* data);
void preferences_on_preferencesdialog_response (GtkDialog* source, gint response, Preferences* self);
void item_preferences_show (ItemPreferences* self);
void preferences_on_preferencesdialog_destroy (GtkWidget* source, Preferences* self);
Preferences* preferences_new (void);
Preferences* preferences_construct (GType object_type);
static GObject * preferences_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
ItemPreferences* item_preferences_new (const gchar* settingskey);
ItemPreferences* item_preferences_construct (GType object_type, const gchar* settingskey);
static void preferences_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

extern const gchar* SETTINGS_CACHE_presetgraphids[6];

static gboolean _vala_string_array_contains (const gchar** stack, int stack_length, const gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean _utils_get_settings_color_gsettings_bind_get_mapping (GValue* value, GVariant* variant, void* user_data) {
	gboolean result;
	result = utils_get_settings_color (value, variant, user_data);
	return result;
}


static GVariant* _utils_set_settings_color_gsettings_bind_set_mapping (GValue* value, const GVariantType* expected_type, void* user_data) {
	GVariant* result;
	result = utils_set_settings_color (value, expected_type, user_data);
	return result;
}


static void _______lambda8_ (void) {
}


static void ________lambda8__gdestroy_notify (void* data) {
	_______lambda8_ ();
}


static void ____lambda9_ (void) {
}


static void _____lambda9__gdestroy_notify (void* data) {
	____lambda9_ ();
}


void preferences_show (Preferences* self) {
	GtkDialog* _tmp0_;
	GtkBuilder* builder = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gint _tmp5__length1;
	GtkBuilder* _tmp6_ = NULL;
	GObject* _tmp7_ = NULL;
	GtkDialog* _tmp8_;
	SettingsCache* _tmp9_;
	SettingsCache* settingscache;
	SettingsCache* _tmp10_;
	GSettings* _tmp11_ = NULL;
	GSettings* prefsettings;
	GSettings* _tmp12_;
	gchar** _tmp13_;
	gchar** _tmp14_ = NULL;
	gchar** graphids;
	gint graphids_length1;
	gint _graphids_size_;
	gchar** _tmp15_;
	gint _tmp15__length1;
	GSettings* _tmp66_;
	GtkBuilder* _tmp67_;
	GObject* _tmp68_ = NULL;
	GSettings* _tmp69_;
	GtkBuilder* _tmp70_;
	GObject* _tmp71_ = NULL;
	GSettings* _tmp72_;
	GtkBuilder* _tmp73_;
	GObject* _tmp74_ = NULL;
	GtkDialog* _tmp75_;
	g_return_if_fail (IS_PREFERENCES (self));
	_tmp0_ = self->priv->preferences;
	if (_tmp0_ != NULL) {
		GtkDialog* _tmp1_;
		_tmp1_ = self->priv->preferences;
		gtk_window_present (GTK_WINDOW (_tmp1_));
		return;
	}
	_tmp2_ = g_strdup ("widthadjustment");
	_tmp3_ = g_strdup ("speedadjustment");
	_tmp4_ = g_new0 (gchar*, 2 + 1);
	_tmp4_[0] = _tmp2_;
	_tmp4_[1] = _tmp3_;
	_tmp5_ = _tmp4_;
	_tmp5__length1 = 2;
	_tmp7_ = utils_get_ui ("preferencesdialog", G_OBJECT (self), _tmp5_, 2, &_tmp6_);
	_g_object_unref0 (builder);
	builder = _tmp6_;
	_g_object_unref0 (self->priv->preferences);
	self->priv->preferences = GTK_IS_DIALOG (_tmp7_) ? ((GtkDialog*) _tmp7_) : NULL;
	_tmp5_ = (_vala_array_free (_tmp5_, _tmp5__length1, (GDestroyNotify) g_free), NULL);
	_tmp8_ = self->priv->preferences;
	g_return_if_fail (_tmp8_ != NULL);
	_tmp9_ = settings_cache_new ();
	settingscache = _tmp9_;
	_tmp10_ = settingscache;
	_tmp11_ = settings_cache_generalsettings (_tmp10_);
	prefsettings = _tmp11_;
	_tmp12_ = prefsettings;
	_tmp14_ = _tmp13_ = g_settings_get_strv (_tmp12_, "graphs");
	graphids = _tmp14_;
	graphids_length1 = _vala_array_length (_tmp13_);
	_graphids_size_ = graphids_length1;
	_tmp15_ = graphids;
	_tmp15__length1 = graphids_length1;
	{
		gchar** graphid_collection = NULL;
		gint graphid_collection_length1 = 0;
		gint _graphid_collection_size_ = 0;
		gint graphid_it = 0;
		graphid_collection = _tmp15_;
		graphid_collection_length1 = _tmp15__length1;
		for (graphid_it = 0; graphid_it < _tmp15__length1; graphid_it = graphid_it + 1) {
			gchar* _tmp16_;
			gchar* graphid = NULL;
			_tmp16_ = g_strdup (graphid_collection[graphid_it]);
			graphid = _tmp16_;
			{
				const gchar* _tmp17_;
				SettingsCache* _tmp18_;
				const gchar* _tmp19_;
				GSettings* _tmp20_ = NULL;
				GSettings* graphsettings;
				GSettings* _tmp21_;
				gchar** _tmp22_;
				gchar** _tmp23_ = NULL;
				gchar** traceids;
				gint traceids_length1;
				gint _traceids_size_;
				GSettings* _tmp45_;
				GtkBuilder* _tmp46_;
				const gchar* _tmp47_;
				const gchar* _tmp48_ = NULL;
				gchar* _tmp49_ = NULL;
				gchar* _tmp50_;
				GObject* _tmp51_ = NULL;
				GSettings* _tmp52_;
				GtkBuilder* _tmp53_;
				const gchar* _tmp54_;
				const gchar* _tmp55_ = NULL;
				gchar* _tmp56_ = NULL;
				gchar* _tmp57_;
				GObject* _tmp58_ = NULL;
				GSettings* _tmp59_;
				GtkBuilder* _tmp60_;
				const gchar* _tmp61_;
				const gchar* _tmp62_ = NULL;
				gchar* _tmp63_ = NULL;
				gchar* _tmp64_;
				GObject* _tmp65_ = NULL;
				_tmp17_ = graphid;
				if (!_vala_string_array_contains (SETTINGS_CACHE_presetgraphids, G_N_ELEMENTS (SETTINGS_CACHE_presetgraphids), _tmp17_)) {
					_g_free0 (graphid);
					continue;
				}
				_tmp18_ = settingscache;
				_tmp19_ = graphid;
				_tmp20_ = settings_cache_graphsettings (_tmp18_, _tmp19_);
				graphsettings = _tmp20_;
				_tmp21_ = graphsettings;
				_tmp23_ = _tmp22_ = g_settings_get_strv (_tmp21_, "traces");
				traceids = _tmp23_;
				traceids_length1 = _vala_array_length (_tmp22_);
				_traceids_size_ = traceids_length1;
				{
					guint j;
					gchar** _tmp24_;
					gint _tmp24__length1;
					guint jsize;
					j = (guint) 0;
					_tmp24_ = traceids;
					_tmp24__length1 = traceids_length1;
					jsize = (guint) _tmp24__length1;
					{
						gboolean _tmp25_;
						_tmp25_ = TRUE;
						while (TRUE) {
							gboolean _tmp26_;
							guint _tmp28_;
							guint _tmp29_;
							gchar** _tmp30_;
							gint _tmp30__length1;
							guint _tmp31_;
							const gchar* _tmp32_;
							gchar* _tmp33_;
							gchar* traceid;
							SettingsCache* _tmp34_;
							const gchar* _tmp35_;
							const gchar* _tmp36_;
							GSettings* _tmp37_ = NULL;
							GSettings* tracesettings;
							GSettings* _tmp38_;
							GtkBuilder* _tmp39_;
							const gchar* _tmp40_;
							const gchar* _tmp41_ = NULL;
							gchar* _tmp42_ = NULL;
							gchar* _tmp43_;
							GObject* _tmp44_ = NULL;
							_tmp26_ = _tmp25_;
							if (!_tmp26_) {
								guint _tmp27_;
								_tmp27_ = j;
								j = _tmp27_ + 1;
							}
							_tmp25_ = FALSE;
							_tmp28_ = j;
							_tmp29_ = jsize;
							if (!(_tmp28_ < _tmp29_)) {
								break;
							}
							_tmp30_ = traceids;
							_tmp30__length1 = traceids_length1;
							_tmp31_ = j;
							_tmp32_ = _tmp30_[_tmp31_];
							_tmp33_ = g_strdup (_tmp32_);
							traceid = _tmp33_;
							_tmp34_ = settingscache;
							_tmp35_ = graphid;
							_tmp36_ = traceid;
							_tmp37_ = settings_cache_tracesettings (_tmp34_, _tmp35_, _tmp36_);
							tracesettings = _tmp37_;
							_tmp38_ = tracesettings;
							_tmp39_ = builder;
							_tmp40_ = traceid;
							_tmp41_ = string_to_string (_tmp40_);
							_tmp42_ = g_strconcat (_tmp41_, "_color", NULL);
							_tmp43_ = _tmp42_;
							_tmp44_ = gtk_builder_get_object (_tmp39_, _tmp43_);
							g_settings_bind_with_mapping (_tmp38_, "color", _tmp44_, "color", G_SETTINGS_BIND_DEFAULT, _utils_get_settings_color_gsettings_bind_get_mapping, _utils_set_settings_color_gsettings_bind_set_mapping, NULL, ________lambda8__gdestroy_notify);
							_g_free0 (_tmp43_);
							_g_object_unref0 (tracesettings);
							_g_free0 (traceid);
						}
					}
				}
				_tmp45_ = graphsettings;
				_tmp46_ = builder;
				_tmp47_ = graphid;
				_tmp48_ = string_to_string (_tmp47_);
				_tmp49_ = g_strconcat (_tmp48_, "_enabled", NULL);
				_tmp50_ = _tmp49_;
				_tmp51_ = gtk_builder_get_object (_tmp46_, _tmp50_);
				g_settings_bind (_tmp45_, "enabled", _tmp51_, "active", G_SETTINGS_BIND_DEFAULT);
				_g_free0 (_tmp50_);
				_tmp52_ = graphsettings;
				_tmp53_ = builder;
				_tmp54_ = graphid;
				_tmp55_ = string_to_string (_tmp54_);
				_tmp56_ = g_strconcat (_tmp55_, "_background_color", NULL);
				_tmp57_ = _tmp56_;
				_tmp58_ = gtk_builder_get_object (_tmp53_, _tmp57_);
				g_settings_bind_with_mapping (_tmp52_, "background-color", _tmp58_, "color", G_SETTINGS_BIND_DEFAULT, _utils_get_settings_color_gsettings_bind_get_mapping, _utils_set_settings_color_gsettings_bind_set_mapping, NULL, _____lambda9__gdestroy_notify);
				_g_free0 (_tmp57_);
				_tmp59_ = graphsettings;
				_tmp60_ = builder;
				_tmp61_ = graphid;
				_tmp62_ = string_to_string (_tmp61_);
				_tmp63_ = g_strconcat (_tmp62_, "_background_color", NULL);
				_tmp64_ = _tmp63_;
				_tmp65_ = gtk_builder_get_object (_tmp60_, _tmp64_);
				g_settings_bind (_tmp59_, "alpha", _tmp65_, "alpha", G_SETTINGS_BIND_DEFAULT);
				_g_free0 (_tmp64_);
				traceids = (_vala_array_free (traceids, traceids_length1, (GDestroyNotify) g_free), NULL);
				_g_object_unref0 (graphsettings);
				_g_free0 (graphid);
			}
		}
	}
	_tmp66_ = prefsettings;
	_tmp67_ = builder;
	_tmp68_ = gtk_builder_get_object (_tmp67_, "width");
	g_settings_bind (_tmp66_, "width", _tmp68_, "value", G_SETTINGS_BIND_DEFAULT);
	_tmp69_ = prefsettings;
	_tmp70_ = builder;
	_tmp71_ = gtk_builder_get_object (_tmp70_, "speed");
	g_settings_bind (_tmp69_, "speed", _tmp71_, "value", G_SETTINGS_BIND_DEFAULT);
	_tmp72_ = prefsettings;
	_tmp73_ = builder;
	_tmp74_ = gtk_builder_get_object (_tmp73_, "autostart");
	g_settings_bind (_tmp72_, "autostart", _tmp74_, "active", G_SETTINGS_BIND_DEFAULT);
	_tmp75_ = self->priv->preferences;
	gtk_widget_show_all (GTK_WIDGET (_tmp75_));
	graphids = (_vala_array_free (graphids, graphids_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (prefsettings);
	_g_object_unref0 (settingscache);
	_g_object_unref0 (builder);
}


void preferences_on_preferencesdialog_response (GtkDialog* source, gint response, Preferences* self) {
	gint _tmp0_;
	g_return_if_fail (IS_PREFERENCES (self));
	g_return_if_fail (GTK_IS_DIALOG (source));
	_tmp0_ = response;
	switch (_tmp0_) {
		case 1:
		{
			ItemPreferences* _tmp1_;
			_tmp1_ = self->priv->menupreferences;
			item_preferences_show (_tmp1_);
			return;
		}
		case 2:
		{
			ItemPreferences* _tmp2_;
			_tmp2_ = self->priv->indicatorpreferences;
			item_preferences_show (_tmp2_);
			return;
		}
		default:
		{
			GtkDialog* _tmp3_;
			_tmp3_ = source;
			gtk_widget_destroy (GTK_WIDGET (_tmp3_));
			return;
		}
	}
}


void preferences_on_preferencesdialog_destroy (GtkWidget* source, Preferences* self) {
	g_return_if_fail (IS_PREFERENCES (self));
	g_return_if_fail (GTK_IS_WIDGET (source));
	_g_object_unref0 (self->priv->preferences);
	self->priv->preferences = NULL;
}


Preferences* preferences_construct (GType object_type) {
	Preferences * self = NULL;
	self = (Preferences*) g_object_new (object_type, NULL);
	return self;
}


Preferences* preferences_new (void) {
	return preferences_construct (TYPE_PREFERENCES);
}


static GObject * preferences_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	Preferences * self;
	ItemPreferences* _tmp0_;
	ItemPreferences* _tmp1_;
	parent_class = G_OBJECT_CLASS (preferences_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = PREFERENCES (obj);
	_tmp0_ = item_preferences_new ("menu-expressions");
	_g_object_unref0 (self->priv->menupreferences);
	self->priv->menupreferences = _tmp0_;
	_tmp1_ = item_preferences_new ("indicator-expressions");
	_g_object_unref0 (self->priv->indicatorpreferences);
	self->priv->indicatorpreferences = _tmp1_;
	return obj;
}


static void preferences_class_init (PreferencesClass * klass) {
	preferences_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PreferencesPrivate));
	G_OBJECT_CLASS (klass)->constructor = preferences_constructor;
	G_OBJECT_CLASS (klass)->finalize = preferences_finalize;
}


static void preferences_instance_init (Preferences * self) {
	self->priv = PREFERENCES_GET_PRIVATE (self);
}


static void preferences_finalize (GObject* obj) {
	Preferences * self;
	self = PREFERENCES (obj);
	_g_object_unref0 (self->priv->preferences);
	_g_object_unref0 (self->priv->menupreferences);
	_g_object_unref0 (self->priv->indicatorpreferences);
	G_OBJECT_CLASS (preferences_parent_class)->finalize (obj);
}


/******************************************************************************
 * Copyright (C) 2011  Michael Hofmann <mh21@piware.de>                       *
 *                                                                            *
 * This program is free software; you can redistribute it and/or modify       *
 * it under the terms of the GNU General Public License as published by       *
 * the Free Software Foundation; either version 3 of the License, or          *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU General Public License for more details.                               *
 *                                                                            *
 * You should have received a copy of the GNU General Public License along    *
 * with this program; if not, write to the Free Software Foundation, Inc.,    *
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.                *
 ******************************************************************************/
GType preferences_get_type (void) {
	static volatile gsize preferences_type_id__volatile = 0;
	if (g_once_init_enter (&preferences_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PreferencesClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) preferences_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Preferences), 0, (GInstanceInitFunc) preferences_instance_init, NULL };
		GType preferences_type_id;
		preferences_type_id = g_type_register_static (G_TYPE_OBJECT, "Preferences", &g_define_type_info, 0);
		g_once_init_leave (&preferences_type_id__volatile, preferences_type_id);
	}
	return preferences_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



